#!/usr/bin/env -S python3 -u
import json
import os
import re
from threading import Thread
from time import sleep, time

import paho.mqtt.client
import paho.mqtt.publish

DEBUG = os.environ.get('DEBUG') == '1'
EVENT_TIMEOUT = int(os.environ.get('EVENT_TIMEOUT', 2))
MQTT_CLIENT_ID = os.environ.get('MQTT_CLIENT_ID', 'mqtt_triggers')
MQTT_HOST = os.environ.get('MQTT_HOST', 'localhost')
MQTT_PORT = int(os.environ.get('MQTT_PORT', '1883'))
MQTT_TOPIC = os.environ.get('MQTT_TOPIC', 'zwave/#,plug02/switch/plug_02_relay/state')
MQTT_QOS = int(os.environ.get('MQTT_QOS', 1))

frontdoor_lock_state = {'last_update': 0, 'users': set()}
frontdoor_lock_status = {'locked': None}
frontdoor_lock_users = ['Someone', 'Zach', 'Contractor', 'Jessica']


def mqtt_send(topic, payload):
    try:
        if DEBUG:
            print(f'Sending to MQTT: {topic}: {payload}')
        paho.mqtt.publish.single(topic, payload=payload, qos=MQTT_QOS, hostname=MQTT_HOST, port=MQTT_PORT)

    except Exception as ex:
        print("MQTT Publish Failed: " + str(ex))


def on_connect(mqtt, userdata, flags, rc):
    """Callback for MQTT connects."""
    #print("MQTT connected: " + mqtt.connack_string(rc))
    print("MQTT connected")
    if rc != 0:
        print("Could not connect. Error: " + str(rc))
    else:
        for topic in MQTT_TOPIC.split(','):
            mqtt.subscribe(topic.strip())


def on_disconnect(mqtt, userdata, rc):
    """Callback for MQTT disconnects."""
    print("MQTT disconnected: " + mqtt.connack_string(rc))


def on_log(mqtt, obj, level, string):
    if level < 16:
        print('***', string)


def on_message(mqtt, userdata, msg):
    """Callback for MQTT message PUBLISH."""
    for event in watched_events:
        match = event['match'].match(msg.topic)
        if match:
            if type(msg.payload) == bytes:
                msg.payload = msg.payload.decode('utf-8')
            event['callback'](msg, *match.groups(''))


def event_office_switch(msg, *args):
    """Callback for the office switch being pressed.
    """
    packet = json.loads(msg.payload)
    command = 'on' if packet['value'] else 'off'

    print(f'*** Office lights {command}, turning {command} enail.')
    mqtt_send('plug03/switch/plug_03_relay/command', command)


def bed_lights_off(timeout=120):
    """Turn the bed lights off after a timeout.
    """
    sleep(timeout)
    print('*** Turning off bed lights now.')
    mqtt_send('plug02/switch/plug_02_relay/command', 'off')


def event_bed_lights(msg, *args):
    """Callback for the bed lights being turned on
    """
    if msg.payload.lower() == 'on':
        print('*** Turning off bed lights in 2 minutes.')
        Thread(target=bed_lights_off, name='bed_lights_off', daemon=True).start()


def event_frontdoor_lock(msg, *args):
    """Callback for frontdoor lock events.
    """
    global frontdoor_lock_state
    packet = json.loads(msg.payload)

    if msg.topic == 'zwave/2/113/1/260':
        frontdoor_lock_state['users'].add(frontdoor_lock_users[int(packet['value'])])

    elif msg.topic == 'zwave/2/113/1/6':
        if packet['value'] == 'Clear':
             if frontdoor_lock_state['last_update']:
                 print('Firing event:', frontdoor_lock_state, frontdoor_lock_status)
             frontdoor_lock_state = {'last_update': 0, 'users': set()}
        else:
            frontdoor_lock_state['operation'] = packet['value']
            frontdoor_lock_state['last_update'] = time()

    elif msg.topic == 'zwave/2/98/1/0':
        frontdoor_lock_status['locked'] = packet['value']


def event_door_window_sensor(msg, *args):
    """Callback for frontdoor lock events.
    """
    packet = json.loads(msg.payload)
    sensor = 'backdoor' if packet['node_id'] == 3 else f'unknown_{packet["node_id"]}'
    door_window = 'Door'
    status = 'opened' if packet['value'] else 'closed'

    mqtt_send(f'discord/{sensor}', f"{door_window} has been {status}.")
    


if __name__ == '__main__':
    # A list of event dictionaries.
    # Each event dictionary consists of 1 or more keys:
    #
    #     `match`
    #         A compiled regex object (re.compile()).
    #     `callback`
    #         The function to call when a match is encountered. 
    #         `*match.groups('')` will be passed to this function.
    watched_events = [
        {
            'match': re.compile(r'zwave/Office/3/37/1/0'),
            'callback': event_office_switch,
        },
        {
            'match': re.compile(r'plug02/switch/plug_02_relay/state'),
            'callback': event_bed_lights,
        },
        {
            'match': re.compile(r'zwave/[0-9]+/48/1/0'),
            'callback': event_door_window_sensor,
        },
    ]

    # Setup and start the mqtt app
    mqtt = paho.mqtt.client.Client('mqtt_triggers')
    mqtt.on_connect = on_connect
    mqtt.on_disconnect = on_disconnect
    mqtt.on_log = on_log
    mqtt.on_message = on_message
    mqtt.connect(MQTT_HOST, MQTT_PORT, 60)
    mqtt.loop_forever()
    #while True:
    #    mqtt.loop()
